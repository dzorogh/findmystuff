# ADR 002: Entity-config как единый контракт списка сущностей

## Статус

Принято.

## Контекст

В приложении много сущностей с похожим UX: список с колонками, фильтрами, сортировкой, пагинацией и действиями (удалить, восстановить, дублировать и т.д.). Без общего контракта каждый список реализовывался бы отдельно, с дублированием кода и несогласованным поведением.

## Решение

- **Единый контракт списка** задаётся конфигом сущности в `lib/entities/<entity>/entity-config.ts`: колонки (`columns`), фильтры (`filters`), функция загрузки (`fetch`), метки (`labels`), действия (`actions`), при необходимости пагинация и счётчики.
- **Типы конфига** определены в `lib/app/types/entity-config.ts` (EntityDisplay, Filters, EntityLabels, ListColumnConfig, FetchListResult и др.).
- **Рендер списка** унифицирован: хук `useListPage` (состояние, URL, вызов fetch) + компоненты `EntityList` / `EntityListPage`. Страница списка — по сути `<EntityListPage config={itemsEntityConfig} />` или кастомная обёртка с тем же конфигом.
- **Добавление новой сущности** (см. CONTRIBUTING): миграции, entity-config, API в `lib/<entity>/api.ts`, маршруты в `app/api/<entity>/`, страницы списка и детали.

## Следствия

- Одинаковое поведение списков (фильтры, сортировка, URL-состояние); новая сущность подключается без нового UI-кода для таблицы.
- Типы в `lib/app/types/entity-config.ts` — один источник правды для контракта; конфиги в `lib/entities/*` реализуют этот контракт.
- Термин «entity-config» используется и для типов (в `lib/app/types/`), и для конфигов (в `lib/entities/`); различие описано в README.
