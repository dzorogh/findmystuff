# ADR 001: Доступ к данным только через API-клиенты

## Статус

Принято.

## Контекст

Приложение использует Supabase (PostgreSQL + Auth). Прямые вызовы `createClient()` и запросы к БД из любого кода приводят к смешению слоёв, дублированию логики и усложнению тестирования. Нужно чётко разделить: где разрешён доступ к БД, а где приложение должно ходить только в собственные API.

## Решение

- **Серверный доступ к Supabase/БД** разрешён только в:
  - `lib/*/api.ts` (доменные API-функции, RPC, запросы к таблицам);
  - `lib/shared/api/**` (общие хелперы для API);
  - `app/api/**` (маршруты Next.js API);
  - `contexts/**` (глобальные контексты, в т.ч. tenant);
  - `components/auth/**` (вход, регистрация, сброс пароля).

- **Исключение для auth-подписки:** в `lib/users/context.tsx` используется `createClient()` только для подписки на изменение состояния авторизации (`onAuthStateChange`). Прямых запросов к таблицам (`.from()`, `.rpc()` и т.п.) из этого контекста нет; это допустимое исключение для синхронизации текущего пользователя с UI.

- **Страницы приложения** (`app/(app)/**`), **остальные компоненты и хуки** не импортируют `createClient` и не выполняют прямые запросы к Supabase. Они используют **API-клиенты** из `lib/*/api.ts` (например `getRooms`, `createRoom`, `getItem`), которые делают запросы к `app/api/*`.

- Ограничение проверяется **ESLint**: правила разрешают импорт и использование Supabase только в перечисленных путях. Проверка: `npm run lint`.

## Следствия

- Единая точка входа к данным через маршруты `/api/*`; проще добавлять auth, tenant_id, логирование.
- Клиентский код не зависит от Supabase напрямую; возможна замена бэкенда при сохранении контрактов API.
- Юнит-тесты страниц и компонентов мокают API-клиенты, а не БД.
